HackTrade 1.3
=============
Фреймворк для написания торговых роботов.

Краткое руководство
-------------------
В данном руководстве рассказано из каких частей состоит торговый робот. Руководство расчитано на пользователя с начальными знаниями программирования или языка **Lua**.

Итак, минимальный робот в **HackTrade** состоит из 3-х элементов:

1. Исполнения основного модуля
2. Определения основной функции
3. Вызова функции **Trade**, для осуществления торговых действий

```lua
dofile("hacktrade.lua")

function Robot()
  Trade()
end
```

Фреймворк состоит из одного файла [hacktrade.lua](hacktrade.lua). Для инициализации фреймворка вы должны в первую очередь исполнить файл с его кодом. Для этого используется стандартная функция **dofile** в которой указывается путь к файлу (в приведённом примере фреймворк находится в той же папке, что и робот).

Следующий шаг - объявление функции **Robot**. Эта функция должна содержать код робота, при этом она выполнена в формате сопрограммы и может быть явно прервана на любом этапе выполнения. Это позволяет фреймворку заходить в функцию и продолжать её выполнение, тем самым вы не должны явно вставлять код обработки заявок и получения данных, фреймворк это сделает за вас, только передайте ему управление. Такой подход к написанию робота позволяет вам без лишних управляющих структур запрограммировать конечный автомат. Это даёт возможность создавать предсказуемых и наджных роботов.

Чтобы передать управление фреймворку и обработать заявки объявлена специальная функция **Trade**. Когда вы вызываете эту функцию, выполнение функции **Robot** прерывается и фреймворк получает управления для совершения полезной работы: пересчёт заявок, выставление и снятие заявок. Когда фреймворк закончит полезную работу, то он снова вызовет функцию **Robot** с того же места, где последний раз вызывалась функция **Trade**.

Когда в функции **Robot** исполнятся все строки, робот завершится. Поэтому робот, приведённый выше, завершиться практически сразу после запуска. Чтобы ваш робот торговал продолжительное время, вам необходимо создать бесконечный цикл, в котором вызывается функция **Trade**:

```lua
dofile("hacktrade.lua")

function Robot()
  while true do
    Trade()
  end
end
```

Теперь ваш робот будет работать, пока вы его явно не остановите.

Рыночные данные
---------------

Для получения рыночных данных доступны два типа объектов: **MarketData** и **Indicator**. Первый позволяет получить данные о последней сделке и стакане, а второй информацию с графиков. Добавим объект **MarketData** к нашему роботу:


```lua
dofile("hacktrade.lua")

function Robot()

  feed = MarketData{
    market = "QJSIM",
    ticker = "SBER",
  }

  while true do
    Trade()
  end
end
```

Для создания экземпляра объекта необходимо передать параметры: *код рынка* и *тикер*. В результате создаётся объект и сохраняется в переменную **feed**. Экземпляр будет использоваться для получения цены последней сделки.

Чтобы получить различные параметры торгового инструмента, обратитесь к атрибутам объекта **feed**;

```lua
feed.last             -- Цена последней сделки
feed.last             -- Цена последней сделки
feed.volume           -- Объём последней сделки
feed.high             -- Максимальная цена за торговую сессию
feed.bid              -- Лучшая цена спроса
feed.offer            -- Лучшая цена предложения
feed.sec_scale        -- Точность цены
feed.sec_price_step   -- Минимальный шаг цены
```

Доступны и другие параметры, названия которых вы можете посмотреть в документации к терминалу **QUIK**.

Умные заявки
------------

На данный функционал вдохновила система **QATCH**. Заявка в фреймворке **HackTrade** представляет собой динамическую лимитную заявку с изменяемой ценой. При этом также может меняться количество и даже направление. Главное, то нужно запомнить, "умная заявка" будет пытаться набирать указанное количество лотов по заданной цене. Даже если вы снимите заявку торговой систем, **SmartOrder** породит новую и продолжить добирать заданное ранее количество (представьте, что SmartOrder** - это заявка, которая гарантированно набирает зданный объём).

Для большинства роботов на хватит одной умной заявки, но вы можете создавать их больше, например для арбитражной стратегии. где для каждого инструмента должна быть своя умная заявка, либо для маркет-мейкера, когда в рынке стоят сразу несколько заявок. Давайте создадим одну такую заявку:

```lua
dofile("hacktrade.lua")

function Robot()

  feed = MarketData{
    market = "MCODE",
    ticker = "TCKR",
  }
  
  order = SmartOrder{
    market = "MCODE",
    ticker = "TCKR",
    account = "ACNT1234567890",
    client = "775533",
  }

  while true do
    Trade()
  end
end
```

Для создания заявки требуется указать: рынок, тикер с которыми будет работать заявка, а также номер счёта и код клиента, чтобы определить, от имени какого пользователя и по какому счёту будет торговать система (если у вас много счетов, можете создать одного универсального работа, либо склонировать его и адаптировать под разные счета и инструменты).

На умных заявках технически не сложно реализовать ступенчатые заяки, такие как айсберг (очень простой пример):

```lua
while true do
  if order.position == 0 then
    order:update(feed.last, 10)
  elseif order.position == 10 then
    order:update(feed.last, 20)
  end
  Trade()
end
```

Программный интерфейс (API)
---------------------------

Компиляция роботов (предпродажная подготовка)
---------------------------------------------
